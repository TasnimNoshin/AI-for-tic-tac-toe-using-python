def main():
    state=eval(input("Enter the state of the board: "))
    player=input("Player: ")
    result=TreeBuildAB(state,player)
#Enter state as(['X','O',' ','O','O','X',' ','X',' '])
#TreeBuildAB(['X','O',' ','O','O','X',' ','X',' '],'X')    
    
def TreeBuildAB(S,player):
#takes initial state and player initial
#returns a list of all game states generated by the game tree with root S
    t=helper(S,player,True,-2,2)
    return t

def helper(S,player,isMax,alpha,beta):
#helper takes player,the state of the board, a boolean value, alpha and beta to give the best move    
    p=[]#list of game states
    for n in range(len(S)):
        p.append(S[n])#adding the current state to the list
    if player=='X':#checking if the player is X
        opponent='O'#assigning O as opponent
    else:
        opponent='X'#if player is O, assign X as opponent
    if isWinner(S,player)==True:#checking if player is winner
        if isMax==True:#checking if its players turn
            p.append(1)#addding max value to indicate player won
            p.append(player)#adding X or O
            p.append((-1,-1))#adding players move
            p.append(1)#if players turn change alpha to max value
            p.append(beta)#keep beta unchanged
            print("State= ",p[:9]," Value= ", p[9])#printing currnet state and value

            return p
        else:
             p.append(-1) #addding min value to indicate opponent won
             p.append(player)#adding X or O
             p.append((-1,-1))#adding players move
             p.append(alpha)#keep alpha unchanged
             p.append(-1)#if opponents turn change beta to min value
             print("State= ",p[:9]," Value= ", p[9])#printing currnet state and value

             return p
    if isWinner(S,opponent)==True:
        if isMax==True:
            p.append(-1)#addding min value to indicate opponent won
            p.append(player)#adding X or O
            p.append((-1,-1))#adding players move
            p.append(-1)#if opponents turn change alpha to min value
            p.append(beta)#keep beta unchanged
            print("State= ",p[:9]," Value= ", p[9])#printing currnet state and value

            return p
        else:
            p.append(1)#addding max value to indicate player won
            p.append(player)#adding X or O
            p.append((-1,-1))#adding players move
            p.append(alpha)#keep alpha unchanged
            p.append(1)#if players turn change beta to max value
            print("State= ",p[:9]," Value= ", p[9])#printing currnet state and value

            return p
    full=True #a variable to see if the board is full
    for i in range(len(S)):
        if S[i]==' ':
            full=False #if there is an empty space, means board is not full
            break
    if full==True: #in case the game is a draw
         p.append(0)
         p.append(player)
         p.append((-1,-1))
         if isMax==True:
             p.append(0)
             p.append(beta)
         else:
             p.append(alpha)
             p.append(0)
         print("State= ",p[:9]," Value= ", p[9])
         return p

    count=[]#keeps track of the empty spaces in the state
    for j in range(len(S)):
        if S[j]==' ':
            count.append(j)
    value=[]#list of values
    for k in range(len(count)):
        S[count[k]]=player #place player in the empty space to get the value for that position
        h=helper(S,opponent,not isMax,alpha,beta) #call helper on opponent
        a=h[-2] #alpha value
        b=h[-1] #beta value
        if isMax==True: #if players turn
            if b>alpha:
                alpha=b #if new beta is bigger than given alpha set alpha to be new beta
        else: #if opponentss turn
            if a<beta:
                beta=a #if new alpha is bigger than given beta set beta to be new alpha
        value.append(h[9]) #add opponents value to the list of values
        S[count[k]]=' '

        if alpha>=beta:
            break #if alpha is bigger than or equal to beta break

    if isMax==True: #if its the players turn
        v=max(value) #get the maximum value 
        index=value.index(max(value))
    else:
        v=min(value)#get the miniimum value 
        index=value.index(min(value))
    move=(count[index]//3,count[index]%3) #the best move
    p.append(v)
    p.append(player)
    p.append(move)
    p.append(alpha)
    p.append(beta)
    print("State= ",p[:9]," Value= ", p[9])
    return p
    
def isWinner(state, letter):
#checks which combinations are winning combinations and returns true or false
    return ((state[6] == letter and state[7] == letter and state[8] == letter) or # across the top
            (state[3] == letter and state[4] == letter and state[5] == letter) or # across the middle
            (state[0] == letter and state[1] == letter and state[2] == letter) or # across the bottom
            (state[6] == letter and state[3] == letter and state[0] == letter) or # down the left side
            (state[7] == letter and state[4] == letter and state[1] == letter) or # down the middle
            (state[8] == letter and state[5] == letter and state[2] == letter) or # down the right side
            (state[6] == letter and state[4] == letter and state[2] == letter) or # diagonal
            (state[8] == letter and state[4] == letter and state[0] == letter)) # diagonal
   
                

