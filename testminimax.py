def main():
    state=eval(input("Enter the state of the board: "))#ask the user to print the current state of the board
    player=input("Player: ")#ask who the player is(X or O)
    TreeBuild(state,player)
    
#Enter state as(['X','O',' ','O','O','X',' ','X',' '])
#TreeBuild(['X','O',' ','O','O','X',' ','X',' '],'X')    

def TreeBuild(S,player):
#takes initial state and player initial
#returns a list of all game states generated by the game tree with root S
    t=helper(S,player,True)
    return t


def helper(S,player,isMax):
#helper takes player,the state of the board and a boolean value to give the best move
    p=[]#list of game states
    for n in range(len(S)):
        p.append(S[n])#adding the current state to the list
    if player=='X':#checking if the player is X
        opponent='O'#assigning O as opponent
    else:
        opponent='X'#if player is O, assign X as opponent
    if isWinner(S,player)==True:#checking if player is winner
        if isMax==True:#checking if its players turn
            p.append(1)#addding max value to indicate player won
            p.append(player)#adding X or O
            p.append((-1,-1))#adding players move
            print("State= ",p[:9]," Value= ", p[9])#printing currnet state and value 
            return p
        else:#if it is opponents turn
             p.append(-1)#addding min value to indicate opponent won
             p.append(player)#adding X or O
             p.append((-1,-1))#adding opponentss move
             print("State= ",p[:9]," Value= ", p[9])#printing currnet state and value
             return p
    if isWinner(S,opponent)==True:#checking if opponent is winner
        if isMax==True:#checking if its opponents turn
            p.append(-1)#addding min value to indicate opponent won
            p.append(player)#adding X or O
            p.append((-1,-1))#adding opponents move
            print("State= ",p[:9]," Value= ", p[9])#printing currnet state and value
            return p
        else:
            p.append(1)#addding max value to indicate player won
            p.append(player)#adding X or O
            p.append((-1,-1))#adding players move
            print("State= ",p[:9]," Value= ", p[9])#printing currnet state and value
            return p
    full=True #a variable to see if the board is full
    for i in range(len(S)):
        if S[i]==' ':
            full=False #if there is an empty space, means board is not full
            break
    if full==True:#in case the game is a draw
         p.append(0)
         p.append(player)
         p.append((-1,-1))
         print("State= ",p[:9]," Value= ", p[9])
         return p

    count=[]#keeps track of the empty spaces in the state
    for j in range(len(S)):
        if S[j]==' ':
            count.append(j)
    value=[]#list of values
    for k in range(len(count)):
        S[count[k]]=player #place player in the empty space to get the value for that position
        h=helper(S,opponent,not isMax) #call helper on opponent 
        value.append(h[9]) #add opponents value to the list of values
        S[count[k]]=' '
    if isMax==True:#if its the players turn
        v=max(value)#get the maximum value 
        index=value.index(max(value))#helps to find the players best move
    else:
        v=min(value)#get the miniimum value 
        index=value.index(min(value))#helps to find the opponents best move
    move=(count[index]//3,count[index]%3)#the best move
    p.append(v)
    p.append(player)
    p.append(move)
    print("State= ",p[:9]," Value= ", p[9])
    return p
    
def isWinner(state, letter):
#checks which combinations are winning combinations and returns true or false 
    return ((state[6] == letter and state[7] == letter and state[8] == letter) or # across the top
            (state[3] == letter and state[4] == letter and state[5] == letter) or # across the middle
            (state[0] == letter and state[1] == letter and state[2] == letter) or # across the bottom
            (state[6] == letter and state[3] == letter and state[0] == letter) or # down the left side
            (state[7] == letter and state[4] == letter and state[1] == letter) or # down the middle
            (state[8] == letter and state[5] == letter and state[2] == letter) or # down the right side
            (state[6] == letter and state[4] == letter and state[2] == letter) or # diagonal
            (state[8] == letter and state[4] == letter and state[0] == letter)) # diagonal
   
                

