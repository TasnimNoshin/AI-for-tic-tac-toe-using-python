def main():
    printIntro()
    n,init= getInputs()
    winsA = minimaxttt(n,init)
    print(winsA)
#Enter the state in this format without any quotations( , , , , , , , , )
#main()
#Is it 0,1 or 2 player mode?: 0/1/2
#Enter the initial state and seperate the positions with comma(','):  , , , , , , , , 
    

def printIntro(): 
    return "Welcome to the game of tic-tac-toe!!!"#print an introduction

def getInputs():
#get all the necessary inputs for the game 
    n=int(input("Is it 0,1 or 2 player mode?: "))#ask for how many players are playing 
    init=input("Enter the initial state and seperate the positions with comma(','): ").split(',')#ask for the initial state
    return n,init

def TreeBuild(S,player):
#takes initial state and player initial
#returns a list of all game states generated by the game tree with root S
    return helper(S,player,True)

def helper(S,player,isMax):
#helper takes player,the state of the board and a boolean value to give the best move
    p=[]#list of game states
    for n in range(len(S)):
        p.append(S[n])#adding the current state to the list
    if player=='X':#checking if the player is X
        opponent='O'#assigning O as opponent
    else:
        opponent='X'#if player is O, assign X as opponent
    if isWinner(S,player)==True:#checking if player is winner
        if isMax==True:#checking if its players turn
            p.append(1)#addding max value to indicate player won
            p.append(player)#adding X or O
            p.append((-1,-1))#adding players move
            return p #return a list of game state
        else:#if it is opponents turn
             p.append(-1)#addding min value to indicate opponent won
             p.append(player)#adding X or O
             p.append((-1,-1))#adding opponentss move
             return p #return a list of game state
    if isWinner(S,opponent)==True:#checking if opponent is winner
        if isMax==True:#checking if its opponents turn
            p.append(-1)#addding min value to indicate opponent won
            p.append(player)#adding X or O
            p.append((-1,-1))#adding opponents move
            return p #return a list of game state
        else:
            p.append(1)#addding max value to indicate player won
            p.append(player)#adding X or O
            p.append((-1,-1))#adding players move
            return p #return a list of game state
    full=True #a variable to see if the board is full
    for i in range(len(S)):
        if S[i]==' ':
            full=False #if there is an empty space, means board is not full
            break
    if full==True: #in case the game is a draw
         p.append(0)
         p.append(player)
         p.append((-1,-1))
         return p

    count=[]#keeps track of the empty spaces in the state
    for j in range(len(S)):
        if S[j]==' ':
            count.append(j)
    value=[] #list of values
    for k in range(len(count)):
        S[count[k]]=player #place player in the empty space to get the value for that position
        h=helper(S,opponent,not isMax) #call helper on opponent
        value.append(h[9]) #add opponents value to the list of values
        S[count[k]]=' '
    if isMax==True:#if its the players turn
        v=max(value)#get the maximum value 
        index=value.index(max(value))#helps to find the players best move
    else:
        v=min(value)#get the miniimum value
        index=value.index(min(value))#helps to find the opponents best move
    move=(count[index]//3,count[index]%3)#the best move
    p.append(v)
    p.append(player)
    p.append(move)
    return p
    
def isWinner(state, letter):
#checks which combinations are winning combinations and returns true or false 
    return ((state[6] == letter and state[7] == letter and state[8] == letter) or # across the top
            (state[3] == letter and state[4] == letter and state[5] == letter) or # across the middle
            (state[0] == letter and state[1] == letter and state[2] == letter) or # across the bottom
            (state[6] == letter and state[3] == letter and state[0] == letter) or # down the left side
            (state[7] == letter and state[4] == letter and state[1] == letter) or # down the middle
            (state[8] == letter and state[5] == letter and state[2] == letter) or # down the right side
            (state[6] == letter and state[4] == letter and state[2] == letter) or # diagonal
            (state[8] == letter and state[4] == letter and state[0] == letter)) # diagonal
   
def initialState(init):
#prints the current board
    print("Current State: ")
    n=0
    print("-------")
    for x in range(3):
        print('|',end='')
        for y in range(3):
            print(init[n],end='|')
            n=n+1
        print()
        print("-------")
       
def currentState(current,player,letter):
# takes the current state,player and their letter and updates initial state
    current[player]=letter
    initialState(current)
        
def minimaxttt(n,init):
#playes the game
    initialState(init)#print initial state
    playerA,playerB='',''
    current=init 
    letter=''
    while (isBoardFull(current)==False): #while there are empty space in the board
        if n==0: #checking if its computer against computer
            computerA=TreeBuild(current,'X')[-1] #calling TreeBuild() function to get the best move
            computerA=coordinateSystem(computerA) #change it into numbers
            currentState(current,computerA,'X') #draw the current state
            if(isWinner(current,'X')==True): 
                return("Computer A is the winner") #if X is winner print this statement
            if isBoardFull(current)==True: break #if board is full break the loop
            computerB=TreeBuild(current,'O')[-1] #calling TreeBuild() function to get the best move
            computerB=coordinateSystem(computerB)#change it into numbers
            currentState(current,computerB,'O') #draw the current state
            if(isWinner(current,'O')==True):
                return("Computer B is the winner") #if O is winner print this statement
        if n==1: #checking if its computer against human
            playerA=eval(input("A-player's next move: ")) #ask user for move
            playerA=coordinateSystem(playerA)#change it into numbers
            while isSpaceFree(current,playerA)!=True:#if the position is not empty
                print("Space is not empty. try another position") 
                playerA=eval(input("A-player's next move: ")) #ask for another move
                playerA=coordinateSystem(playerA) #change it into numbers
            currentState(current,playerA,'X') #draw the current state
            if(isWinner(current,'X')==True):
                return("Player A is the winner")#if user is winner print this statement
            if isBoardFull(current)==True: break #if board is full break the loop
            computer=TreeBuild(current,'O')[-1] #calling TreeBuild() function to get the best move
            computer=coordinateSystem(computer) #change it into numbers
            currentState(current,computer,'O') #draw the current state
            if(isWinner(current,'O')==True):
                return("Computer is the winner") #if computer is winner print this statement
        if n==2: #checking if its human against human
            while not (letter=='X' or letter=='O'):
                letter=input("Does player A want to be X or O?: ") #ask what is player A's preference
            if letter=='X':
                print("Player A is X and player B is O") #print a statement to let the players know which one is their letter
                letterA='X'
                letterB='O'
            else:
                print("Player A is O and player B is X")#print a statement to let the players know which one is their letter 
                letterA='O'
                letterB='X'
            playerA=eval(input("A-player's next move: ")) #ask user for move
            playerA=coordinateSystem(playerA) #change it into numbers
            while isSpaceFree(current,playerA)!=True: #if the position is not empty
                print("Space is not empty. try another position")
                playerA=eval(input("A-player's next move: ")) #ask for another move
                playerA=coordinateSystem(playerA) #change it into numbers
            currentState(current,playerA,letterA) #draw the current state
            if(isWinner(current,letterA)==True):
                return ("Player A is the winner") #if player A is winner print this statement
            if isBoardFull(current)==True: break #if board is full break the loop
            playerB=eval(input("B-player's next move: ")) #ask user for move
            playerB=coordinateSystem(playerB) #change it into numbers
            while isSpaceFree(current,playerB)!=True: #if the position is not empty
                print("Space is not empty. try another position")
                playerB=eval(input("B-player's next move: ")) #ask for another move
                playerB=coordinateSystem(playerB) #change it into numbers
            currentState(current,playerB,letterB) #draw the current state
            if(isWinner(current,letterB)==True):
                return ("Player B is the winner") #if player B is winner print this statement
            if isBoardFull(current)==True: break #if board is full break the loop
    return ("The match is draw") #if theboard is empty and there is no winner print this statement

def coordinateSystem(player):
#given the coordinates by the user as tuples change them into number
    a=player[0]
    b=player[1]
    n=0
    for i in range(3):
        for j in range(3):
            if i==int(a) and j==int(b):
                return n
            else:
                n=n+1

def isBoardFull(state):
# Return True if every space on the board has been taken. Otherwise return False.
    for i in range(9):
        if isSpaceFree(state, i):
            return False
    return True
 
def isSpaceFree(state, move):
#Return true if the passed move is free on the passed board.
    return state[move] == ' '
